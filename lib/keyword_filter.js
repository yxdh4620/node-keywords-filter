// Generated by CoffeeScript 1.6.3
(function() {
  var NodeTree, change_case, infor, position, replaceIndexChar, rollback, rootNode, subNode, tempNode;

  NodeTree = require("./module/node_tree");

  infor = require("./data/information");

  change_case = require("./util/change_case");

  rootNode = NodeTree.getInstance();

  tempNode = null;

  subNode = null;

  rollback = 0;

  position = 0;

  replaceIndexChar = function(str, index, char) {
    if (index < 0 || index + 1 >= str.length) {
      return str;
    }
    return str.substring(0, index) + char + str.substring(index + 1, str.length);
  };

  module.exports = {
    init: function(keyArray, isChange) {
      if (isChange == null) {
        isChange = true;
      }
      infor.initData(keyArray);
      return this.createNodeTree(isChange);
    },
    createNodeTree: function(isChange) {
      var char, i, j, key, keyArray, _i, _len, _results;
      if (isChange == null) {
        isChange = true;
      }
      console.log("[createNodeTree start]");
      keyArray = infor.getKeyArray();
      _results = [];
      for (i = _i = 0, _len = keyArray.length; _i < _len; i = ++_i) {
        key = keyArray[i];
        if (isChange) {
          key = change_case.change(key);
        }
        tempNode = rootNode;
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (j = _j = 0, _len1 = key.length; _j < _len1; j = ++_j) {
            char = key[j];
            subNode = tempNode.getNode(char);
            if (subNode === void 0) {
              subNode = NodeTree.getInstance();
              tempNode.setNode(char, subNode);
            }
            tempNode = subNode;
            if (j === key.length - 1) {
              _results1.push(subNode.setEnd(true));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    },
    isContainKeyword: function(str) {
      var char;
      tempNode = rootNode;
      rollback = 0;
      position = 0;
      str = change_case.change(str);
      while (position < str.length) {
        char = str.charAt(position);
        tempNode = tempNode.getNode(char);
        if (tempNode === void 0) {
          position = position - rollback;
          rollback = 0;
          tempNode = rootNode;
        } else if (tempNode.isEnd()) {
          return true;
        } else {
          rollback++;
        }
        position++;
      }
      return false;
    },
    replaceKeyword: function(str, isChange, reChar) {
      var i, _i, _ref, _ref1;
      if (isChange == null) {
        isChange = true;
      }
      if (reChar == null) {
        reChar = '*';
      }
      tempNode = rootNode;
      rollback = 0;
      position = 0;
      if (isChange) {
        str = change_case.change(str);
      }
      while (position < str.length) {
        tempNode = tempNode.getNode(str.charAt(position));
        if (tempNode === void 0) {
          position = position - rollback;
          rollback = 0;
          tempNode = rootNode;
        } else if (tempNode.isEnd()) {
          for (i = _i = _ref = position - rollback, _ref1 = position + 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
            str = replaceIndexChar(str, i, reChar);
          }
          rollback = 1;
        } else {
          rollback++;
        }
        position++;
      }
      return str;
    },
    replaceStrKeyword: function(str, isChange, reStr) {
      if (isChange == null) {
        isChange = true;
      }
      if (reStr == null) {
        reStr = '敏感词';
      }
      tempNode = rootNode;
      rollback = 0;
      position = 0;
      if (isChange) {
        str = change_case.change(str);
      }
      while (position < str.length) {
        tempNode = tempNode.getNode(str.charAt(position));
        if (tempNode === void 0) {
          position = position - rollback;
          rollback = 0;
          tempNode = rootNode;
        } else if (tempNode.isEnd()) {
          str = str.replace(str.substring(position - rollback, position + 1), reStr);
          rollback = 1;
        } else {
          rollback++;
        }
        position++;
      }
      return str;
    }
  };

}).call(this);
